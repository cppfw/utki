from conans import ConanFile, CMake, tools

class UtkiConan(ConanFile):
	name = "utki"
	version = "$(version)"
	license = "MIT"
	author = "Ivan Gagis <igagis@gmail.com>"
	url = "http://github.com/cppfw/" + name
	description = "Utility C++ library"
	topics = ("C++", "cross-platform")
	settings = "os", "compiler", "build_type", "arch"
	options = {"shared": [True, False], "fPIC": [True, False]}
	default_options = {"shared": False, "fPIC": True}
	generators = "make"

	source_dir = "../../source/" + name + "/"

	def config_options(self):
		if self.settings.os == "Windows":
			del self.options.fPIC

	def source(self):
		self.run("git clone https://github.com/cppfw/" + self.name + ".git")
		if self.version != "none":
			self.run("cd " + self.name + " && git checkout " + self.version)

		# This small hack might be useful to guarantee proper /MT /MD linkage
		# in MSVC if the packaged project doesn't have variables to set it
		# properly
# 		tools.replace_in_file("hello/CMakeLists.txt", "PROJECT(HelloWorld)",
# 							'''PROJECT(HelloWorld)
# include(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake)
# conan_basic_setup()''')

	def build(self):
		self.run("make --directory " + self.source_dir + " autojobs=true")
		self.run("make --directory " + self.source_dir + " autojobs=true test")
		# cmake = CMake(self)
		# cmake.configure(source_folder="../../source/utki/src")
		# cmake.build()

		# Explicit way:
		# self.run('cmake %s/hello %s'
		#          % (self.source_folder, cmake.command_line))
		# self.run("cmake --build . %s" % cmake.build_config)

	def package(self):
		self.copy("*.h", dst="include", src=self.source_dir + "src")
		self.copy("*.hpp", dst="include", src=self.source_dir + "src")
		self.copy("*" + self.name + ".lib", dst="lib", keep_path=False)
		self.copy("*.dll", dst="bin", src=self.source_dir +   "src/out/rel", keep_path=False)
		self.copy("*.so", dst="lib", src=self.source_dir +    "src/out/rel", keep_path=False)
		self.copy("*.so.*", dst="lib", src=self.source_dir +  "src/out/rel", keep_path=False)
		self.copy("*.dylib", dst="lib", src=self.source_dir + "src/out/rel", keep_path=False)
		self.copy("*.a", dst="lib", src=self.source_dir +     "src/out/rel", keep_path=False)

	def package_info(self):
		self.cpp_info.libs = [self.name]
